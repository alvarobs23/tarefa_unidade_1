#include <stdio.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "pico/stdlib.h"
#include "hardware/gpio.h"

#define BUTTON_GPIO 4 // Defina o pino do botão
#define LED_GPIO 2    // Defina o pino do LED

#define BUTTON_PRESSED 1
#define BUTTON_RELEASED 0

QueueHandle_t buttonQueue;

void Task_ReadButton(void *pvParameters) {
    gpio_init(BUTTON_GPIO);
    gpio_set_dir(BUTTON_GPIO, GPIO_IN);
    gpio_pull_up(BUTTON_GPIO); // Habilita pull-up interno
    
    int buttonState = BUTTON_RELEASED;
    while (1) {
        buttonState = gpio_get(BUTTON_GPIO) ? BUTTON_RELEASED : BUTTON_PRESSED; // Botão ativo em LOW
        xQueueSend(buttonQueue, &buttonState, portMAX_DELAY);
        vTaskDelay(pdMS_TO_TICKS(100)); // Executa a cada 100ms
    }
}

void Task_ProcessButton(void *pvParameters) {
    int receivedState;
    while (1) {
        if (xQueueReceive(buttonQueue, &receivedState, portMAX_DELAY)) {
            xQueueSend(buttonQueue, &receivedState, portMAX_DELAY); // Enviar para a Task do LED
        }
    }
}

void Task_ControlLED(void *pvParameters) {
    gpio_init(LED_GPIO);
    gpio_set_dir(LED_GPIO, GPIO_OUT);
    
    int ledState = 0;
    while (1) {
        if (xQueueReceive(buttonQueue, &ledState, portMAX_DELAY)) {
            gpio_put(LED_GPIO, ledState); // Liga/desliga o LED
            printf("LED %s!\n", ledState ? "Ligado" : "Desligado");
        }
    }
}

int main(void) {
    stdio_init_all(); // Inicializa saída padrão para debug
    
    buttonQueue = xQueueCreate(5, sizeof(int));
    if (buttonQueue == NULL) {
        printf("Erro ao criar a fila!\n");
        return 1;
    }

    xTaskCreate(Task_ReadButton, "ReadButton", 1000, NULL, 1, NULL);
    xTaskCreate(Task_ProcessButton, "ProcessButton", 1000, NULL, 2, NULL);
    xTaskCreate(Task_ControlLED, "ControlLED", 1000, NULL, 3, NULL);

    vTaskStartScheduler(); // Inicia o agendador do FreeRTOS
    for (;;);
}
